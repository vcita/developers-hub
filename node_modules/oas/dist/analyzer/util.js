"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.refizePointer = exports.query = void 0;
var jsonpath_1 = __importDefault(require("jsonpath"));
/**
 * Run a set of JSONPath queries against an API definition.
 *
 * @see {@link https://jsonpath.com/}
 * @see {@link https://npm.im/jsonpath}
 */
function query(queries, definition) {
    var results = queries
        .map(function (q) { return jsonpath_1["default"].nodes(definition, q); })
        .filter(function (res) { return (res.length ? res : false); })
        .reduce(function (prev, next) { return prev.concat(next); }, [])
        .map(function (node) {
        var path = node.path.slice(1).map(function (p) { return String(p).split('/').join('~1'); });
        return {
            // `jsonpath` has a `$` root reference, that we sliced off already, but we want `/` instead.
            pointer: "/".concat(path.join('/')),
            value: node.value
        };
    });
    // Always alphabetize our results by the JSON pointer.
    results.sort(function (a, b) {
        if (a.pointer < b.pointer) {
            return -1;
        }
        else if (a.pointer > b.pointer) {
            return 1;
        }
        return 0;
    });
    return results;
}
exports.query = query;
/**
 * Transform a JSON pointer into a JSON Schema `$ref`-compatible pointer.
 *
 * @example `/paths/~1streams/post/callbacks` -> `#/paths/~1streams/post/callbacks`
 */
function refizePointer(pointer) {
    return "#".concat(pointer);
}
exports.refizePointer = refizePointer;
